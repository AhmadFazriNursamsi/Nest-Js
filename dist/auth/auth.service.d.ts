import { JwtService } from '@nestjs/jwt';
import { DeepPartial, ObjectLiteral } from 'typeorm';
import { RateLimiterRes, RateLimiterStoreAbstract } from 'rate-limiter-flexible';
import { MailService } from 'src/mail/mail.service';
import { Pagination } from 'src/paginate';
import { RefreshToken } from 'src/refresh-token/entities/refresh-token.entity';
import { RefreshTokenService } from 'src/refresh-token/refresh-token.service';
import { ChangePasswordDto } from 'src/auth/dto/change-password.dto';
import { ForgetPasswordDto } from 'src/auth/dto/forget-password.dto';
import { ResetPasswordDto } from 'src/auth/dto/reset-password.dto';
import { UserLoginDto } from 'src/auth/dto/user-login.dto';
import { UserSearchFilterDto } from 'src/auth/dto/user-search-filter.dto';
import { UserEntity } from 'src/auth/entity/user.entity';
import { UserSerializer } from 'src/auth/serializer/user.serializer';
import { UserRepository } from 'src/auth/user.repository';
import { RefreshPaginateFilterDto } from 'src/refresh-token/dto/refresh-paginate-filter.dto';
import { RefreshTokenSerializer } from 'src/refresh-token/serializer/refresh-token.serializer';
export declare class AuthService {
    private readonly userRepository;
    private readonly jwt;
    private readonly mailService;
    private readonly refreshTokenService;
    private readonly rateLimiter;
    constructor(userRepository: UserRepository, jwt: JwtService, mailService: MailService, refreshTokenService: RefreshTokenService, rateLimiter: RateLimiterStoreAbstract);
    sendMailToUser(user: UserSerializer, subject: string, url: string, slug: string, linkLabel: string): Promise<void>;
    create(createUserDto: DeepPartial<UserEntity>): Promise<UserSerializer>;
    findBy(field: string, value: string): Promise<UserSerializer>;
    login(userLoginDto: UserLoginDto, refreshTokenPayload: Partial<RefreshToken>): Promise<string[]>;
    generateAccessToken(user: UserSerializer, isTwoFAAuthenticated?: boolean): Promise<string>;
    limitConsumerPromiseHandler(usernameIPkey: string): Promise<[RateLimiterRes, RateLimiterRes]>;
    get(user: UserEntity): Promise<UserSerializer>;
    findById(id: number): Promise<UserSerializer>;
    findAll(userSearchFilterDto: UserSearchFilterDto): Promise<Pagination<UserSerializer>>;
    update(id: number, updateUserDto: DeepPartial<UserEntity>): Promise<UserSerializer>;
    activateAccount(token: string): Promise<void>;
    forgotPassword(forgetPasswordDto: ForgetPasswordDto): Promise<void>;
    resetPassword(resetPasswordDto: ResetPasswordDto): Promise<void>;
    changePassword(user: UserEntity, changePasswordDto: ChangePasswordDto): Promise<void>;
    generateRandomCode(length: number, uppercase?: boolean, lowercase?: boolean, numerical?: boolean): string;
    generateUniqueToken(length: number): Promise<string>;
    getCookieForLogOut(): string[];
    buildResponsePayload(accessToken: string, refreshToken?: string): string[];
    createAccessTokenFromRefreshToken(refreshToken: string): Promise<string[]>;
    revokeRefreshToken(encoded: string): Promise<void>;
    activeRefreshTokenList(userId: number, filter: RefreshPaginateFilterDto): Promise<Pagination<RefreshTokenSerializer>>;
    revokeTokenById(id: number, userId: number): Promise<RefreshToken>;
    setTwoFactorAuthenticationSecret(secret: string, userId: number): Promise<import("typeorm").UpdateResult>;
    turnOnTwoFactorAuthentication(user: UserEntity, isTwoFAEnabled: boolean, qrDataUri: string): Promise<import("typeorm").UpdateResult>;
    countByCondition(condition: ObjectLiteral): Promise<number>;
    getRefreshTokenGroupedData(field: string): Promise<any[]>;
}
